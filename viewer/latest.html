<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="app-version" content="v0.4.7"/>
<title>Concepts JSON Viewer</title>
<style>
  :root{
    --bg:#f6f7f9; --panel:#fff; --line:#e5e7eb; --text:#111827; --muted:#6b7280;
    --btn:#fff; --btnh:#fafafa;
  }
  body.dark{
    --bg:#0b0f14; --panel:#0f1620; --line:#223042; --text:#e6edf3; --muted:#8a93a0;
    --btn:#121a25; --btnh:#182333;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);transition:background .15s,color .15s;}
  #topbar{
    position:fixed; inset:10px 10px auto 10px; z-index:10;
    padding:8px 10px; background:var(--panel); border:1px solid var(--line);
    border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,.08);
    font:14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  #topbar label{display:flex; gap:6px; align-items:center; min-width:0;}
  #topbar input[type="file"]{font-size:12px;}
  #topbar input[type="number"]{width:88px; padding:3px 6px;}
  #topbar button{padding:6px 10px; border-radius:8px; border:1px solid var(--line); background:var(--btn); cursor:pointer; color:var(--text);}
  #topbar button:hover{background:var(--btnh);}
  #zoomRange{width:100%;}
  .sections{display:grid; grid-template-columns: 1fr; gap:10px;}
  @media(min-width:1200px){ .sections{grid-template-columns: 1.3fr 1.6fr 2fr 1.1fr;} }
  .section{display:flex; flex-direction:column; gap:6px; min-width:0;}
  .section .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center;}
#topbar .section .controls #toggleImagesBtn{order:-2;}
#topbar .section .controls .img-opacity{order:-1; min-width:240px;}
#topbar .section .controls #selInfo{margin-left:auto;}
  .section-label{font-size:11px; letter-spacing:.06em; text-transform:uppercase; color:var(--muted);}
  .muted{color:var(--muted);font-size:12px;white-space:nowrap;}
  .spacer{flex:1 1 auto;}
  canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block; background:transparent;}
  a.dl{color:inherit; text-decoration:none; border:1px solid var(--line); padding:6px 10px; border-radius:8px;}
#topbar .export-actions{display:inline-flex; gap:8px; flex-wrap:nowrap; white-space:nowrap;}
#topbar .section .controls #toggleImagesBtn{order:0}
#topbar .section .controls #pickImg{order:1}
#topbar .section .controls #flipSelX{order:2}
#topbar .section .controls #flipSelY{order:3}
#topbar .section .controls #flipAllX{order:4}
#topbar .section .controls #flipAllY{order:5}
#topbar .section .controls #clearAllFlips{order:6}
#topbar .section .controls .img-opacity{order:7; min-width:260px;}
#topbar .section .controls #selInfo{order:99; margin-left:auto;}

  /* Header row (brand + version + info) */
  #topbar .toprow{display:flex; align-items:center; justify-content:flex-start; gap:10px; margin-bottom:6px}
  #topbar .brand{font-weight:700; letter-spacing:.01em; display:flex; align-items:center; gap:10px}
  #topbar button.btn-ghost{background:transparent; border:1px solid var(--line); border-radius:10px; padding:6px 9px; opacity:.85}
  #topbar button.btn-ghost:hover{background:var(--btnh); opacity:1}

</style>
</head>
<body>
  <div id="topbar">
  <div class="toprow">
    <div class="brand">Concepts App iOS File Viewer <span id="verInline" class="muted">v0.4.7</span>
      <button id="openInfo" class="btn-ghost" title="Info & Tutorial" style="margin-left:8px;" onclick="document.getElementById('modalOverlay').style.display='flex'">Info</button>
    </div>
  </div>

    <div class="sections">
      <!-- FILES -->
      <div class="section">
        <div class="section-label">Files</div>
        <div class="controls">
          <label>JSON <input type="file" id="jsonFile" accept=".json,application/json"></label>
          <label>Images <input type="file" id="imgFiles" multiple></label>
        </div>
      </div>

      <!-- CANVAS -->
      <div class="section">
        <div class="section-label">Canvas</div>
        <div class="controls">
          <button id="centerBtn" title="Fit to drawing (robust)">Center</button>
          <label><input id="showGrid" type="checkbox" checked> Grid</label>
          <button id="mode" title="Toggle Lines/Points">Mode: Lines</button>
          <button id="flipViewX" title="Flip entire view horizontally (does not modify images)">Flip VIEW X</button>
          <button id="flipViewY" title="Flip entire view vertically (does not modify images)">Flip VIEW Y</button>
          <span class="spacer"></span>
          <label title="Dark theme UI"><input type="checkbox" id="darkToggle"> Dark</label>
          <label title="In dark mode, draw strokes in white"><input type="checkbox" id="whiteInk"> White lines</label>
        </div>
      </div>

      <!-- IMAGES -->
      <div class="section">
        <div class="section-label">Images</div>
        <div class="controls">
          <button id="toggleImagesBtn" title="Hide or show all images">Hide images</button>
          <button id="pickImg" title="Pick image to edit (click on canvas)">Pick img</button>
          <button id="flipSelX" title="Flip selected image horizontally">Flip sel X</button>
          <button id="flipSelY" title="Flip selected image vertically">Flip sel Y</button>
          <button id="flipAllX" title="Toggle flip X for ALL images">Flip ALL X</button>
          <button id="flipAllY" title="Toggle flip Y for ALL images">Flip ALL Y</button>
          <button id="clearAllFlips" title="Clear all per-image flips">Clear flips</button>
          <label title="Global opacity for all images" style="min-width:220px;" class="img-opacity" class="img-opacity">Images opacity <input type="range" id="imgOpacity" min="0" max="100" step="1" value="100"></label><span id="selInfo" class="muted"></span>
        </div>
      </div>

      <!-- ZOOM / EXPORT -->
      <div class="section">
        <div class="section-label">Zoom / Export</div>
        <div class="controls">
          <label style="flex:1; min-width:220px;">Zoom <input id="zoomRange" type="range" min="0" max="1" step="0.001" value="0.5"></label>
          <a id="dlLink" class="dl" download="export.png" style="display:none">download</a>
          <span class="export-actions"><button id="expPNG" title="Export current viewport as PNG">Export PNG</button><button id="expSVG" title="Export strokes+images as SVG (world coords)">Export SVG</button></span>
          <span id="info" class="muted"></span>
        </div>
      </div>
    </div>

    <!-- keep legacy inputs hidden -->
    <label style="display:none">MaxJump <input id="maxJump" type="number" step="100" value="2000" style="display:none"></label>
    <label style="display:none"><input id="useClientFilter" type="checkbox" checked style="display:none"> Client-Filter</label>
  </div>

  <canvas id="c"></canvas>

<script>
(() => {
  'use strict';

  // ===== Canvas & state =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let doc = null;

  let scale = 0.5, tx = 0, ty = 0;
  const ZMIN = 0.02, ZMAX = 4.0;
  function clamp(v, lo, hi){ return Math.min(hi, Math.max(lo, v)); }

  let isPanning=false, sx=0, sy=0;
  let flipX=false, flipY=true;
  let rot=0;
  let useLines=true;
  const showGrid = document.getElementById('showGrid');
  const maxJumpInput = document.getElementById('maxJump');
  const useClientFilter = document.getElementById('useClientFilter');

  // Theme toggles
  const darkToggle = document.getElementById('darkToggle');
  const whiteInkToggle = document.getElementById('whiteInk');
    // Couple White lines to Dark mode
  const whiteInkLabel = whiteInkToggle.closest('label');
  function syncWhiteInkUI(){
    const isDark = document.body.classList.contains('dark');
    if(!isDark){
      whiteInkToggle.checked = false;
      try{ localStorage.setItem('viewer_whiteInk','0'); }catch(_){}
    }else{
      if(!whiteInkToggle.checked){
        whiteInkToggle.checked = true;
        try{ localStorage.setItem('viewer_whiteInk','1'); }catch(_){}
      }
    }
    whiteInkToggle.disabled = !isDark;
    if(whiteInkLabel){ whiteInkLabel.style.opacity = isDark ? '1' : '.5'; whiteInkLabel.title = isDark ? 'White lines (dark mode)' : 'Enable Dark to use white lines'; }
  }

  // restore
  try {
    if(localStorage.getItem('viewer_dark')==='1'){ document.body.classList.add('dark'); darkToggle.checked=true; }
    if(localStorage.getItem('viewer_whiteInk')==='1'){ whiteInkToggle.checked=true; }
      } catch(_) {}
  syncWhiteInkUI();
  darkToggle.addEventListener('change', ()=>{
  document.body.classList.toggle('dark', darkToggle.checked);
  try{ localStorage.setItem('viewer_dark', darkToggle.checked?'1':'0'); }catch(_){}
  syncWhiteInkUI();
  draw();
});
  whiteInkToggle.addEventListener('change', ()=>{
    try{ localStorage.setItem('viewer_whiteInk', whiteInkToggle.checked?'1':'0'); }catch(_){}
    draw();
  });
  
  // show/hide all images (persist)
  const TOGGLE_KEY = 'concepts_viewer_showImages_v1';
  let showImages = true;
  try { const v = localStorage.getItem(TOGGLE_KEY); if (v!==null) showImages = v === '1'; } catch(_){}
  const toggleBtn = document.getElementById('toggleImagesBtn');
  function syncToggleBtn(){ toggleBtn.textContent = showImages ? 'Hide images' : 'Show images'; }
  syncToggleBtn();

  // File maps
  const fileMap = new Map();
  // Images opacity slider
  const imgOpacity = document.getElementById('imgOpacity');
function opacityUItoValue(u){
  const x = Math.min(100, Math.max(0, +u||0));
  if(x <= 70) return (x/70)*0.3;        // 0..70% Slider -> 0..0.3 Opacity
  return 0.3 + ((x-70)/30)*0.7;         // 70..100% Slider -> 0.3..1 Opacity
}
function valueToOpacityUI(o){
  const y = Math.min(1, Math.max(0, +o||0));
  if(y <= 0.3) return Math.round((y/0.3)*70);
  return Math.round(70 + ((y-0.3)/0.7)*30);
}
function getImgOpacity(){ return opacityUItoValue(imgOpacity ? imgOpacity.value : 100); }
try{
  const v = localStorage.getItem('viewer_imgOpacity');
  if(v!=null && imgOpacity){
    const num = parseFloat(v);
    imgOpacity.value = (isFinite(num) && num<=1) ? valueToOpacityUI(num) : (''+v);
  }
}catch(_){ }
if(imgOpacity){ imgOpacity.addEventListener('input', ()=>{ try{ localStorage.setItem('viewer_imgOpacity', String(imgOpacity.value)); }catch(_){}; draw(); }); }


  // Slider
  const zoomRange = document.getElementById('zoomRange');
  function sliderToScale(t){ return ZMIN * Math.pow(ZMAX/ZMIN, t); }
  function scaleToSlider(s){ return Math.log(s/ZMIN)/Math.log(ZMAX/ZMIN); }
  function syncSlider(){ zoomRange.value = String(scaleToSlider(scale)); }

  function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; draw(); syncSlider(); }
  addEventListener('resize', resize); resize();

  // ============= UI actions =============
  document.getElementById('mode').onclick = ()=>{ useLines = !useLines; document.getElementById('mode').textContent = 'Mode: ' + (useLines ? 'Lines' : 'Points'); draw(); };
  document.getElementById('centerBtn').onclick = ()=>fitAll(true);
  document.getElementById('flipViewX').onclick = ()=>{ flipX = !flipX; draw(); };
  document.getElementById('flipViewY').onclick = ()=>{ flipY = !flipY; draw(); };
  showGrid.addEventListener('change', ()=> draw());
  toggleBtn.addEventListener('click', ()=>{
    showImages = !showImages;
    try { localStorage.setItem(TOGGLE_KEY, showImages ? '1' : '0'); } catch(_){}
    syncToggleBtn();
    draw();
  });

  // Panning
  canvas.addEventListener('mousedown', e=>{ isPanning=true; sx=e.clientX; sy=e.clientY; });
  canvas.addEventListener('mouseup', ()=> isPanning=false);
  canvas.addEventListener('mouseleave', ()=> isPanning=false);
  canvas.addEventListener('mousemove', e=>{
    if(!isPanning) return;
    tx += (e.clientX - sx)/scale;
    ty += (e.clientY - sy)/scale;
    sx=e.clientX; sy=e.clientY;
    draw();
  });

  // Zoom
  zoomRange.addEventListener('input', ()=>{
    const sNew = clamp(sliderToScale(parseFloat(zoomRange.value)), ZMIN, ZMAX);
    const cx = canvas.width*0.5, cy = canvas.height*0.5;
    const w = screenToWorldWith(scale, tx, ty, rot, flipX, flipY, cx, cy);
    const rf = forwardRotFlip(w.x, w.y);
    scale = sNew;
    tx = cx/scale - rf.x;
    ty = cy/scale - rf.y;
    draw();
  }, {passive:true});

  canvas.addEventListener('wheel', e=>{
    e.preventDefault();
    const factor = 0.0015;
    const sNew = clamp(scale * Math.exp(-e.deltaY * factor), ZMIN, ZMAX);
    const r = canvas.getBoundingClientRect();
    const cx = e.clientX - r.left, cy = e.clientY - r.top;
    const w = screenToWorldWith(scale, tx, ty, rot, flipX, flipY, cx, cy);
    const rf = forwardRotFlip(w.x, w.y);
    scale = sNew;
    tx = cx/scale - rf.x;
    ty = cy/scale - rf.y;
    draw();
  }, {passive:false});

  // ===== Math helpers =====
  function applyViewTransform(){
    ctx.setTransform(scale, 0, 0, scale, 0, 0);
    ctx.translate(tx, ty);
    if (rot) ctx.rotate(rot * Math.PI/2);
    ctx.scale(flipX ? -1 : 1, flipY ? -1 : 1);
  }
  function forwardRotFlip(wx, wy){
    let u = flipX ? -wx : wx;
    let v = flipY ? -wy : wy;
    switch ((rot||0)%4){
      case 1: return {x:-v, y:u};
      case 2: return {x:-u, y:-v};
      case 3: return {x: v, y:-u};
      default: return {x:u,  y:v};
    }
  }
  function screenToWorldWith(s, tx_, ty_, rot_, fx_, fy_, cx, cy){
    let x = cx/s - tx_;
    let y = cy/s - ty_;
    const r = rot_ % 4;
    if (r===1){ const _x=x; x=y;  y=-_x; }
    if (r===2){ x=-x; y=-y; }
    if (r===3){ const _x=x; x=-y; y=_x; }
    if (fx_) x = -x;
    if (fy_) y = -y;
    return {x,y};
  }

  // ===== Data loading =====
  document.getElementById('imgFiles').addEventListener('change', (e)=>{
    fileMap.clear();
    for(const f of e.target.files){
      fileMap.set(f.name, URL.createObjectURL(f));
    }
    draw();
  });
  document.getElementById('jsonFile').addEventListener('change', async (e)=>{ const f = e.target.files[0]; if(!f) return; _setBaseNameFromFileName(f.name);
    const text = await f.text();
    doc = JSON.parse(text);
    fitAll(true);
  });

  // ===== Grid =====
  function drawGrid(){
    if(!showGrid.checked) return;
    applyViewTransform();
    ctx.strokeStyle = document.body.classList.contains('dark') ? 'rgba(255,255,255,.06)' : 'rgba(0,0,0,.08)';
    ctx.lineWidth = 1/scale;
    const step = 500;
    const w = canvas.width/scale, h = canvas.height/scale;
    const x0 = Math.floor((-tx)/step)*step - 2*step;
    const y0 = Math.floor((-ty)/step)*step - 2*step;
    for(let x=x0; x < -tx + w + 2*step; x+=step){ ctx.beginPath(); ctx.moveTo(x, -ty - 2*step); ctx.lineTo(x, -ty + h + 2*step); ctx.stroke(); }
    for(let y=y0; y < -ty + h + 2*step; y+=step){ ctx.beginPath(); ctx.moveTo(-tx - 2*step, y); ctx.lineTo(-tx + w + 2*step, y); ctx.stroke(); }
  }

  // ===== Thumb (optional) =====
  function drawThumb(){
    if(!doc || !doc.hasThumb) return Promise.resolve();
    const url = fileMap.get('Thumb.jpg');
    if(!url) return Promise.resolve();
    return new Promise((resolve)=>{
      const img = new Image();
      img.onload = ()=>{
        applyViewTransform();
        ctx.globalAlpha = getImgOpacity();
        ctx.drawImage(img, 0, 0);
        ctx.globalAlpha = 1.0;
        resolve();
      };
      img.onerror = resolve;
      img.src = url;
    });
  }

  // ===== Per-image flips =====
  function imgKey(it){
    if (it && typeof it.local === 'string' && it.local) return it.local;
    if (it && typeof it.path === 'string' && it.path){
      try { return it.path.split('/').pop() || it.path; } catch(_) { return it.path; }
    }
    return null;
  }
  const IMG_FLIP_LS_KEY = 'concepts_viewer_imgFlipOverride_v2';
  let imgFlipOverride = {};
  try { imgFlipOverride = JSON.parse(localStorage.getItem(IMG_FLIP_LS_KEY) || '{}'); } catch(_) { imgFlipOverride = {}; }
  function setImgFlip(k, fx, fy){
    if(!k) return;
    imgFlipOverride[k] = {fx:!!fx, fy:!!fy};
    try { localStorage.setItem(IMG_FLIP_LS_KEY, JSON.stringify(imgFlipOverride)); } catch(_){}
  }
  function getImgFlip(k){
    if(!k) return {fx:false, fy:false};
    const v = imgFlipOverride[k];
    return v ? {fx:!!v.fx, fy:!!v.fy} : {fx:false, fy:false};
  }

  // ===== Images =====
  function parseCrop(it, sw, sh){
    if (typeof it.crop === 'string'){
      const m = it.crop.match(/\{\{\s*([\d\.\-]+)\s*,\s*([\d\.\-]+)\s*\}\s*,\s*\{\s*([\d\.\-]+)\s*,\s*([\d\.\-]+)\s*\}\}/);
      if (m){
        const cx = parseFloat(m[1]), cy = parseFloat(m[2]), cw = parseFloat(m[3]), ch = parseFloat(m[4]);
        return {sx: cx*sw, sy: cy*sh, sw: cw*sw, sh: ch*sh};
      }
    }
    return {sx:0, sy:0, sw, sh};
  }

  function setTransformFrom4x4(t){
    const a = t[0] ?? 1, b = t[1] ?? 0, c = t[4] ?? 0, d = t[5] ?? 1, e = t[12] ?? 0, f = t[13] ?? 0;
    applyViewTransform();
    ctx.transform(a,b,c,d,e,f);
    return {a,b,c,d,e,f};
  }

  async function drawImages(){
    if (!showImages) return;
    if(!doc || !doc.images) return;
    const tasks = [];
    for(const it of doc.images){
      const fname = it.local || (it.path ? it.path.split('/').pop() : null) || it.path || null;
      if(!fname) continue;
      const url = fileMap.get(fname) || fileMap.get((fname+'').split('/').pop());
      if(!url) continue;

      tasks.push(new Promise(resolve => {
        const img = new Image();
        img.onload = ()=>{
          const t = it.transform || [];
          const {a,b,c,d,e,f} = setTransformFrom4x4(t);
          const sw0 = img.naturalWidth, sh0 = img.naturalHeight;
          const crop = parseCrop(it, sw0, sh0);
          const W = (it.size && it.size[0]) || crop.sw;
          const H = (it.size && it.size[1]) || crop.sh;

          const det = a*d - b*c;
          const autoFlipX = (det < 0) && (it.unmirror !== false);
          const ov = getImgFlip(imgKey(it));

          if (it && Array.isArray(it.offset) && it.offset.length>=2){
            ctx.translate(it.offset[0], it.offset[1]);
          }
          ctx.translate(-W*0.5, -H*0.5);

          if (autoFlipX){
            ctx.translate(W*0.5, H*0.5); ctx.scale(-1, 1); ctx.translate(-W*0.5, -H*0.5);
          }
          if (ov.fx || ov.fy){
            ctx.translate(W*0.5, H*0.5); ctx.scale(ov.fx ? -1 : 1, ov.fy ? -1 : 1); ctx.translate(-W*0.5, -H*0.5);
          }
ctx.globalAlpha = getImgOpacity();
          ctx.drawImage(img, crop.sx, crop.sy, crop.sw, crop.sh, 0, 0, W, H);
          ctx.globalAlpha = 1.0;
          ctx.filter = 'none';
          resolve();
        };
        img.onerror = ()=>resolve();
        img.src = url;
      }));
    }
    await Promise.all(tasks);
  }

  // ===== Strokes =====
  function filterTeleports(pts, maxJump){
    if(!pts || pts.length<2) return pts||[];
    const mj2 = maxJump*maxJump;
    let best=[], cur=[pts[0]];
    for(let i=1;i<pts.length;i++){
      const dx=pts[i][0]-pts[i-1][0], dy=pts[i][1]-pts[i-1][1];
      if(dx*dx+dy*dy<=mj2) cur.push(pts[i]);
      else { if(cur.length>=2 && cur.length>best.length) best = cur; cur=[pts[i]]; }
    }
    if(cur.length>=2 && cur.length>best.length) best = cur;
    return best.length>=2 ? best : pts;
  }

  function drawStrokes(){
    if(!doc) return;
    applyViewTransform();
    const whiteInk = document.body.classList.contains('dark') && whiteInkToggle.checked;
    for(const s of (doc.strokes||[])){
      let pts = (useLines && s.polyline && s.polyline.length>1) ? s.polyline : s.keyPoints;
      if(!pts || pts.length===0) continue;

      if(useClientFilter.checked){
        const mj = parseFloat(maxJumpInput.value)||2000;
        if(pts.length>1) pts = filterTeleports(pts, mj);
        if(pts.length<2 && s.keyPoints && s.keyPoints.length>1) pts = filterTeleports(s.keyPoints, mj);
        if(useLines && pts.length<2) continue;
      }

      const alpha = (s.opacity!=null ? s.opacity : 1) * ((s.color && typeof s.color.a==='number') ? s.color.a : 1);
      let col;
      if(whiteInk){
        col = `rgba(255,255,255,${alpha})`;
      } else {
        col = s.color
          ? `rgba(${Math.round((s.color.r||0)*255)}, ${Math.round((s.color.g||0)*255)}, ${Math.round((s.color.b||0)*255)}, ${alpha})`
          : `rgba(0,0,0,${alpha})`;
      }

      if(useLines && pts.length>1){
        ctx.strokeStyle = col;
        ctx.lineWidth = Math.max(0.5, (s.width||1));
        ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.miterLimit = 2;
        ctx.beginPath();
        ctx.moveTo(pts[0][0], pts[0][1]);
        for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
        ctx.stroke();
      } else {
        const r = Math.max(1, 2/scale);
        ctx.fillStyle = col;
        ctx.beginPath();
        for(const p of pts){ ctx.moveTo(p[0]+r, p[1]); ctx.arc(p[0], p[1], r, 0, Math.PI*2); }
        ctx.fill();
      }
    }
  }

  // ===== Fit / bbox =====
  function collectEffectivePoints(d, robust){
    const ptsAll = [];
    const mj = parseFloat(maxJumpInput.value)||2000;
    for(const s of (d.strokes||[])){
      let pts = (s.polyline && s.polyline.length>1) ? s.polyline : s.keyPoints;
      if(!pts || pts.length===0) continue;
      if(robust){
        pts = filterTeleports(pts, mj);
        if(pts.length<2) continue;
      }
      for(const p of pts){ ptsAll.push(p); }
    }
    return ptsAll;
  }
  function quantile(sortedArr, q){
    if(sortedArr.length===0) return NaN;
    const pos = (sortedArr.length-1)*q;
    const base = Math.floor(pos);
    const rest = pos - base;
    if(sortedArr[base+1]!==undefined){
      return sortedArr[base] + rest*(sortedArr[base+1]-sortedArr[base]);
    }else{
      return sortedArr[base];
    }
  }
  function computeBBox(d, robust){
    const pts = collectEffectivePoints(d, robust);
    if(!pts.length) return null;
    const xs = pts.map(p=>p[0]).sort((a,b)=>a-b);
    const ys = pts.map(p=>p[1]).sort((a,b)=>a-b);
    if(robust){
      const x1 = quantile(xs, 0.02), x2 = quantile(xs, 0.98);
      const y1 = quantile(ys, 0.02), y2 = quantile(ys, 0.98);
      return {minX:x1, minY:y1, maxX:x2, maxY:y2};
    }else{
      return {minX: xs[0], minY: ys[0], maxX: xs[xs.length-1], maxY: ys[ys.length-1]};
    }
  }
  function fitAll(robust){
    if(!doc){ draw(); return; }
    const bb = computeBBox(doc, robust!==false);
    if(!bb){ draw(); return; }
    const pad = 200;
    const w = (bb.maxX - bb.minX) + pad*2;
    const h = (bb.maxY - bb.minY) + pad*2;
    const sx = canvas.width / w;
    const sy = canvas.height / h;
    const sTarget = Math.min(sx, sy);
    const cx = (bb.minX + bb.maxX)/2;
    const cy = (bb.minY + bb.maxY)/2;
    const scrX = canvas.width*0.5;
    const scrY = canvas.height*0.5;
    const fr = forwardRotFlip(cx, cy);
    scale = clamp(sTarget, ZMIN, ZMAX);
    tx = scrX/scale - fr.x;
    ty = scrY/scale - fr.y;
    draw();
  }

  // ===== Draw =====
  async function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width, canvas.height);
    drawGrid();
    await drawThumb();
    await drawImages();
    drawStrokes();
    const sCount = doc ? (doc.strokes||[]).length : 0;
    const iCount = doc ? (doc.images||[]).length : 0;
    document.getElementById('info').textContent = `Strokes: ${sCount} | Images: ${iCount}${showImages?'':' (hidden)'} | Zoom: ${scale.toFixed(2)}`;
    syncSlider();
  }
  draw();

  // ===== Selection & per-image ops =====
  function invert2D(a,b,c,d,e,f){
    const det = a*d - b*c; if (Math.abs(det) < 1e-8) return null;
    const ia=a/det, ib=-b/det, ic=-c/det, id=d/det, ie=-(ia*e+ic*f), iff=-(ib*e+id*f);
    return {a:ia,b:ib,c:ic,d:id,e:ie,f:iff};
  }
  function apply2D(m, x, y){ return {x: m.a*x + m.c*y + m.e, y: m.b*x + m.d*y + m.f}; }
  function screenToWorld(clientX, clientY){
    let x = clientX/scale - tx;
    let y = clientY/scale - ty;
    const r = rot % 4;
    if (r===1){ const _x = x; x = y; y = -_x; }
    if (r===2){ x=-x; y=-y; }
    if (r===3){ const _x = x; x = -y; y = _x; }
    if (flipX) x = -x;
    if (flipY) y = -y;
    return {x,y};
  }
  function hitImageAt(clientX, clientY){
    if(!doc || !doc.images) return null;
    const wpt = screenToWorld(clientX, clientY);
    for(let i=doc.images.length-1; i>=0; i--){
      const it = doc.images[i];
      const t = it.transform || [];
      const a = t[0] ?? 1, b = t[1] ?? 0, c = t[4] ?? 0, d = t[5] ?? 1, e = t[12] ?? 0, f = t[13] ?? 0;
      const inv = invert2D(a,b,c,d,e,f); if(!inv) continue;
      const W = (it.size && it.size[0]) || 1;
      const H = (it.size && it.size[1]) || 1;
      const local = apply2D(inv, wpt.x, wpt.y);
      const lx = local.x + W*0.5;
      const ly = local.y + H*0.5;
      if(lx>=0 && ly>=0 && lx<=W && ly<=H){
        return {it, key: imgKey(it)};
      }
    }
    return null;
  }

  let pickMode=false, selectedImgKey=null;
  function setSelInfo(txt){ document.getElementById('selInfo').textContent = txt||''; }

  const pickBtn = document.getElementById('pickImg');
  if (pickBtn){
    pickBtn.onclick = ()=>{
      pickMode = !pickMode;
      pickBtn.style.opacity = pickMode ? '1' : '.6';
      setSelInfo(pickMode ? 'Pick: click an image…' : (selectedImgKey ? ('Selected: '+selectedImgKey) : ''));
    };
  }
  canvas.addEventListener('click', (e)=>{
    if(!pickMode) return;
    const hit = hitImageAt(e.clientX, e.clientY);
    if(!hit) return;
    selectedImgKey = hit.key;
    pickMode = false;
    pickBtn.style.opacity = '.6';
    setSelInfo('Selected: '+selectedImgKey);
  });

  function flipSel(which){
    if(!selectedImgKey) return;
    const cur = getImgFlip(selectedImgKey);
    setImgFlip(selectedImgKey, which==='x' ? !cur.fx : cur.fx, which==='y' ? !cur.fy : cur.fy);
    draw();
  }
  document.getElementById('flipSelX').onclick = ()=>flipSel('x');
  document.getElementById('flipSelY').onclick = ()=>flipSel('y');

  // Apply flip to ALL images
  document.getElementById('flipAllX').onclick = ()=>{
    if(!doc || !doc.images) return;
    for(const it of doc.images){
      const k = imgKey(it); if(!k) continue;
      const cur = getImgFlip(k);
      setImgFlip(k, !cur.fx, cur.fy);
    }
    draw();
  };
  document.getElementById('flipAllY').onclick = ()=>{
    if(!doc || !doc.images) return;
    for(const it of doc.images){
      const k = imgKey(it); if(!k) continue;
      const cur = getImgFlip(k);
      setImgFlip(k, cur.fx, !cur.fy);
    }
    draw();
  };
  document.getElementById('clearAllFlips').onclick = ()=>{
    try { localStorage.removeItem(IMG_FLIP_LS_KEY); } catch(_){}
    imgFlipOverride = {};
    draw();
  };

  
  // ===== Export filename helpers =====
  let _exportCounter = 0;
  let _baseName = null;
  function _setBaseNameFromFileName(name){
    if(!name){ _baseName = null; return; }
    try{ _baseName = name.replace(/\.[^.]+$/, '') || null; }catch(_){ _baseName = null; }
  }
  function _yyyymmdd(){
    const d = new Date();
    const yy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    return `${yy}${mm}${dd}`;
  }
  function _nextExportName(ext){
    _exportCounter++;
    const base = _baseName || 'Import';
    const tag = _yyyymmdd();
    const num = String(_exportCounter).padStart(3,'0');
    return `${base}_${tag}_${num}.${ext}`;
  }

  // ===== Exporters =====
  const dlLink = document.getElementById('dlLink');
  function downloadBlob(blob, filename){
    let name = filename;
    if(!name){
      const mime = (blob && blob.type)||'';
      const ext = mime.includes('svg') ? 'svg' : (mime.includes('png') ? 'png' : 'dat');
      name = _nextExportName(ext);
    }
    const url = URL.createObjectURL(blob);
    dlLink.href = url; dlLink.download = name; dlLink.style.display='inline-block';
    dlLink.textContent = 'download ' + name;
    dlLink.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); dlLink.style.display='none'; }, 3000);
  }

  document.getElementById('expPNG').onclick = ()=>{
    canvas.toBlob(b=>{ if(b) downloadBlob(b /* auto name */); }, 'image/png', 1);
  };

  document.getElementById('expPNG2').onclick = ()=>{
    const off = document.createElement('canvas');
    off.width = canvas.width*2; off.height = canvas.height*2;
    const octx = off.getContext('2d');
    // render by temporarily doubling scale (anchor at top-left corner)
    const old = {scale, tx, ty};
    scale *= 2; tx *= 2; ty *= 2;
    // draw into offscreen by swapping ctx/canvas temporarily
    const realCtx = ctx, realCanvas = canvas;
    // monkey-patch globals for draw()
    const _orig = {ctx, canvas};
    window._ctx_backup = ctx; window._canvas_backup = canvas;
    // Replace references
    eval('ctx = octx;'); eval('canvas = off;');
    draw().then(()=>{
      off.toBlob(b=>{
        if(b) downloadBlob(b /* auto name */);
        // restore
        eval('ctx = window._ctx_backup;'); eval('canvas = window._canvas_backup;');
        scale = old.scale; tx = old.tx; ty = old.ty;
        draw();
      }, 'image/png', 1);
    });
  };

  document.getElementById('expSVG').onclick = async ()=>{
    if(!doc) return;
    const bb = computeBBox(doc, true) || {minX:-1000, minY:-1000, maxX:1000, maxY:1000};
    const pad = 200;
    const minX = bb.minX - pad, minY = bb.minY - pad, width = (bb.maxX-bb.minX)+pad*2, height=(bb.maxY-bb.minY)+pad*2;
    const parts = [];
    parts.push(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="${minX} ${minY} ${width} ${height}">`);

    // Strokes first
    const whiteInk = document.body.classList.contains('dark') && whiteInkToggle.checked;
    for(const s of (doc.strokes||[])){
      let pts = (s.polyline && s.polyline.length>1) ? s.polyline : s.keyPoints;
      if(!pts || pts.length===0) continue;
      const mj = parseFloat(maxJumpInput.value)||2000;
      pts = filterTeleports(pts, mj);
      if(pts.length<2) continue;
      const alpha = (s.opacity!=null ? s.opacity : 1) * ((s.color && typeof s.color.a==='number') ? s.color.a : 1);
      let col = s.color ? `rgb(${Math.round((s.color.r||0)*255)}, ${Math.round((s.color.g||0)*255)}, ${Math.round((s.color.b||0)*255)})` : 'rgb(0,0,0)';
      if(whiteInk) col = 'rgb(255,255,255)';
      const d = pts.map(p=>p.join(',')).join(' ');
      const w = Math.max(0.5, (s.width||1));
      parts.push(`<polyline fill="none" stroke="${col}" stroke-opacity="${alpha}" stroke-width="${w}" points="${d}"/>`);
    }

    // Images
    if(doc.images && doc.images.length && showImages){
      for(const it of doc.images){
        const fname = it.local || (it.path ? it.path.split('/').pop() : null) || it.path || null;
        if(!fname) continue;
        const url = fileMap.get(fname) || fileMap.get((fname+'').split('/').pop());
        if(!url) continue;

        const dataURL = await new Promise(res=>{
          const img = new Image();
          img.onload = ()=>{
            const sw0 = img.naturalWidth, sh0 = img.naturalHeight;
            const crop = (function(){
              if (typeof it.crop === 'string'){
                const m = it.crop.match(/\{\{\s*([\d\.\-]+)\s*,\s*([\d\.\-]+)\s*\}\s*,\s*\{\s*([\d\.\-]+)\s*,\s*([\d\.\-]+)\s*\}\}/);
                if (m){ return {sx: parseFloat(m[1])*sw0, sy: parseFloat(m[2])*sh0, sw: parseFloat(m[3])*sw0, sh: parseFloat(m[4])*sh0}; }
              }
              return {sx:0, sy:0, sw:sw0, sh:sh0};
            })();
            const W = (it.size && it.size[0]) || crop.sw;
            const H = (it.size && it.size[1]) || crop.sh;
            const off = document.createElement('canvas');
            off.width = crop.sw; off.height = crop.sh;
            off.getContext('2d').drawImage(img, crop.sx, crop.sy, crop.sw, crop.sh, 0,0,crop.sw, crop.sh);
            res(off.toDataURL('image/png'));
          };
          img.onerror = ()=>res(null);
          img.src = url;
        });
        if(!dataURL) continue;

        const t = it.transform || [];
        const a = t[0] ?? 1, b = t[1] ?? 0, c = t[4] ?? 0, d = t[5] ?? 1, e = t[12] ?? 0, f = t[13] ?? 0;
        const W = (it.size && it.size[0]) || 1;
        const H = (it.size && it.size[1]) || 1;

        // Build transform: T * translate(-W/2,-H/2) * [optional flips]
        let xf = `matrix(${a} ${b} ${c} ${d} ${e} ${f}) translate(${-W/2} ${-H/2})`;
        const det = a*d - b*c;
        const autoFlipX = (det < 0) && (it.unmirror !== false);
        const ov = getImgFlip(it.local || it.path);
        if(autoFlipX) xf += ` translate(${W/2} ${H/2}) scale(-1 1) translate(${-W/2} ${-H/2})`;
        if(ov && (ov.fx || ov.fy)) xf += ` translate(${W/2} ${H/2}) scale(${ov.fx?-1:1} ${ov.fy?-1:1}) translate(${-W/2} ${-H/2})`;
        if (it && Array.isArray(it.offset) && it.offset.length>=2){
          xf += ` translate(${it.offset[0]} ${it.offset[1]})`;
        }
        parts.push(`<image href="${dataURL}" width="${W}" height="${H}" transform="${xf}"/>`);
      }
    }

    parts.push(`</svg>`);
    const blob = new Blob([parts.join('')], {type:'image/svg+xml'});
    downloadBlob(blob /* auto name */);
  };


  // Version from meta
  var __meta = document.querySelector('meta[name="app-version"]');
  var VERSION = (__meta && __meta.content) ? __meta.content : 'v0.0.0';
  document.title = 'Concepts JSON Viewer — ' + VERSION;
  var verInline = document.getElementById('verInline'); if(verInline) verInline.textContent = VERSION;
  var verTag = document.getElementById('verTag'); if(verTag) verTag.textContent = VERSION;

  // Modal wiring
  var overlay = document.getElementById('modalOverlay');
  var openInfo = document.getElementById('openInfo');
  var closeInfo = document.getElementById('closeInfo');
  var closeInfo2 = document.getElementById('closeInfo2');
  function showModal(show){ if(overlay){ overlay.style.display = show ? 'flex' : 'none'; } }
  if(openInfo) openInfo.addEventListener('click', function(){ showModal(true); });
  if(closeInfo) closeInfo.addEventListener('click', function(){ showModal(false); });
  if(closeInfo2) closeInfo2.addEventListener('click', function(){ showModal(false); });
  if(overlay) overlay.addEventListener('click', function(e){ if(e.target===overlay) showModal(false); });
  window.addEventListener('keydown', function(e){ if(e.key==='Escape') showModal(false); });

})();</script>

<div id="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="modalTitle" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.45);align-items:center;justify-content:center;z-index:999;">
  <div id="modal" style="font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--panel);color:var(--text);width:min(840px,calc(100% - 32px));max-height:80vh;overflow:auto;border:1px solid var(--line);border-radius:12px;box-shadow:0 12px 36px rgba(0,0,0,.3);">
    <header style="display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--line);position:sticky;top:0;background:inherit;">
      <h3 id="modalTitle" style="margin:0;font-size:16px">Info & Tutorial <span id="verTag" class="muted" style="margin-left:8px;"></span></h3>
      <button id="closeInfo" class="close" title="Close" style="appearance:none;border:1px solid var(--line);border-radius:10px;padding:8px 12px;background:var(--btn);color:var(--text);font-weight:600;cursor:pointer;">Close</button>
    </header>
    <div class="body" style="padding:14px 16px;line-height:1.45">
      <h4 style="margin:16px 0 6px;font-size:14px;text-transform:uppercase;letter-spacing:.06em;color:var(--muted)">Tutorial</h4>
      <ol>
        <li><strong>Load JSON:</strong> Use the “JSON” picker at top left to choose your Concepts export.</li>
        <li><strong>Load images (optional):</strong> Add all referenced images via multi-select.</li>
        <li><strong>Canvas:</strong> Center, Grid, Mode (Strokes/Lines), Flip VIEW X/Y.</li>
        <li><strong>Dark &amp; White lines:</strong> White lines are automatically enabled in Dark mode.</li>
        <li><strong>Images:</strong> Pick img &amp; Flip (sel/ALL X/Y), “Clear flips”, <em>Images opacity</em> (fine control below 30%).</li>
        <li><strong>Zoom / Export:</strong> Zoom slider; Export PNG (viewport) or SVG (world coords). Auto-naming included.</li>
      </ol>

      <h4 style="margin:16px 0 6px;font-size:14px;text-transform:uppercase;letter-spacing:.06em;color:var(--muted)">Legal Notice</h4>
      <p>This tool is not affiliated with the <strong>Concepts</strong> app or its maker <strong>TopHatch, Inc.</strong>. “Concepts” and any names mentioned are trademarks of their respective owners. Support is based on reverse‑engineering saved <code>.concept</code> files. Nothing was decompiled.</p>
      <p>“Apple”, the Apple logo, and “iPad” are trademarks of Apple Inc., registered in the U.S. and other countries. “App Store” is a service mark of Apple Inc.</p>
    </div>
    <footer style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-top:1px solid var(--line);position:sticky;bottom:0;background:inherit;">
      <span id="creditsLeft" class="muted" style="font-size:12px;">© 2025 by Maximilian Georg Liebscher · <a href="https://github.com/maxliebscher/conceptsappiosfileviewer" target="_blank" rel="noopener">github.com/maxliebscher/conceptsappiosfileviewer</a></span>
<button id="closeInfo2" class="close" onclick="document.getElementById('modalOverlay').style.display='none'" style="appearance:none;border:1px solid var(--line);border-radius:10px;padding:8px 12px;background:var(--btn);color:var(--text);font-weight:600;cursor:pointer;">OK</button>
    </footer>
  </div>
</div>


<script>
(function(){
  var meta = document.querySelector('meta[name="app-version"]');
  var v = (meta && meta.content) ? meta.content : 'v0.4.7';
  var verInline = document.getElementById('verInline'); if(verInline) verInline.textContent = v;
  var verTag = document.getElementById('verTag'); if(verTag) verTag.textContent = v;

  var overlay = document.getElementById('modalOverlay');
  var openInfo = document.getElementById('openInfo');
  var close1 = document.getElementById('closeInfo');
  var close2 = document.getElementById('closeInfo2');

  function showModal(show){ if(overlay){ overlay.style.display = show ? 'flex' : 'none'; } }
  if(openInfo) openInfo.addEventListener('click', function(){ showModal(true); });
  if(close1) close1.addEventListener('click', function(){ showModal(false); });
  if(close2) close2.addEventListener('click', function(){ showModal(false); });
  if(overlay) overlay.addEventListener('click', function(e){ if(e.target === overlay) showModal(false); });

  window.addEventListener('keydown', function(e){
    if(e.key === 'Escape'){ showModal(false); }
  });
})();
</script>

</body>
</html>